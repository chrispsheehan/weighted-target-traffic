name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  TF_VAR_project_name: ${{ github.event.repository.name }}
  lambda_traffic_percentage: 90
  ecs_traffic_percentage: 10

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: extractions/setup-just@v2
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Set image_uri output
        shell: bash
        run: just validate

  repo:
    runs-on: ubuntu-latest
    needs: validate
    env:
      TF_VAR_ecr_repo_name: ${{ vars.aws_account_id }}-weighted-target-ecs
      TF_VAR_lambda_code_bucket_name: ${{ vars.aws_account_id }}-weighted-target-lambda-code
    outputs:
      ecr_repo_name: ${{ steps.set-envs.outputs.ECR_REPO_NAME }}
      lambda_code_bucket: ${{ steps.set-envs.outputs.LAMBDA_CODE_BUCKET }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Init
        shell: bash
        run: |
          cd tf/repo
          terraform init
    
      - name: Deploy
        shell: bash
        id: deploy
        run: |
          cd tf/repo
          terraform apply -auto-approve -var-file=${{ github.workspace }}/variables.tfvars

      - name: Set env vars
        id: set-envs
        shell: bash
        run: |
          cd tf/repo
          ECR_REPO_NAME=$(terraform output -raw ecr_repo_name)
          LAMBDA_CODE_BUCKET=$(terraform output -raw lambda_code_bucket)
          echo "ECR_REPO_NAME=$ECR_REPO_NAME" >> $GITHUB_OUTPUT
          echo "LAMBDA_CODE_BUCKET=$LAMBDA_CODE_BUCKET" >> $GITHUB_OUTPUT

  image:
    runs-on: ubuntu-latest
    needs: repo
    outputs:
      image_uri: ${{ steps.set-image-uri.outputs.image_uri }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Build and push detected changes
        id: build-image
        uses: ./.github/actions/build_image
        with:
          aws_account_id: ${{ vars.aws_account_id }}
          aws_region: ${{ vars.aws_region }}
          ecr_repository_name: ${{ needs.repo.outputs.ecr_repo_name }}

      - name: Set image_uri output
        id: set-image-uri
        run: |
          echo "image_uri=${{ env.IMAGE_URI }}" >> $GITHUB_OUTPUT

  code:
    runs-on: ubuntu-latest
    needs: repo
    env:
      lambda_zip: ${{ github.sha }}-${{ github.run_id }}.zip
      lambda_bucket: ${{ needs.repo.outputs.lambda_code_bucket }}
    outputs:
      lambda_zip: ${{ steps.set-s3-key.outputs.s3_file_key }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Build and push detected changes
        id: build-lambda
        uses: ./.github/actions/build_lambda
        with:
          aws_region: ${{ vars.aws_region }}
          bucket_name: ${{ env.lambda_bucket }}

      - name: Set s3 key output
        id: set-s3-key
        run: |
          echo "s3_file_key=${{ env.FILE_KEY }}" >> $GITHUB_OUTPUT

  network:
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      lb_security_group_id: ${{ steps.set-envs.outputs.LB_SECURITY_GROUP_ID }}
      lb_ecs_target_group_arn: ${{ steps.set-envs.outputs.LB_ECS_TARGET_GROUP_ARN }}
      lb_lambda_target_group_arn: ${{ steps.set-envs.outputs.LB_LAMBDA_TARGET_GROUP_ARN }}
      api_invoke_url: ${{ steps.set-envs.outputs.API_INVOKE_URL }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Init
        shell: bash
        run: |
          cd tf/network
          terraform init
    
      - name: Deploy
        shell: bash
        id: deploy
        run: |
          cd tf/network
          terraform apply -auto-approve -var-file=${{ github.workspace }}/variables.tfvars

      - name: Set env vars
        id: set-envs
        shell: bash
        run: |
          cd tf/network
          LB_SECURITY_GROUP_ID=$(terraform output -raw lb_security_group_id)
          API_INVOKE_URL=$(terraform output -raw api_invoke_url)
          LB_ECS_TARGET_GROUP_ARN=$(terraform output -raw lb_ecs_target_group_arn)
          LB_LAMBDA_TARGET_GROUP_ARN=$(terraform output -raw lb_lambda_target_group_arn)
          echo "LB_SECURITY_GROUP_ID=$LB_SECURITY_GROUP_ID" >> $GITHUB_OUTPUT
          echo "API_INVOKE_URL=$API_INVOKE_URL" >> $GITHUB_OUTPUT
          echo "LB_ECS_TARGET_GROUP_ARN=$LB_ECS_TARGET_GROUP_ARN" >> $GITHUB_OUTPUT
          echo "LB_LAMBDA_TARGET_GROUP_ARN=$LB_LAMBDA_TARGET_GROUP_ARN" >> $GITHUB_OUTPUT

  ecs:
    needs:
      - repo
      - image
      - network
    runs-on: ubuntu-latest
    env:
      TF_VAR_ecr_repo_name: ${{ needs.repo.outputs.ecr_repo_name }}
      TF_VAR_ecs_image_uri: ${{ needs.image.outputs.image_uri }}
      TF_VAR_lb_security_group_id: ${{ needs.network.outputs.lb_security_group_id }}
      TF_VAR_lb_target_group_arn: ${{ needs.network.outputs.lb_ecs_target_group_arn}}
      TF_VAR_esc_percentage_traffic: ${{ github.env.ecs_traffic_percentage }}
      TF_VAR_lambda_percentage_traffic: ${{ github.env.lambda_traffic_percentage }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Init
        shell: bash
        run: |
          cd tf/ecs
          terraform init
    
      - name: Deploy
        shell: bash
        id: deploy
        run: |
          cd tf/ecs
          terraform apply -auto-approve -var-file=${{ github.workspace }}/variables.tfvars

  lambda:
    needs: 
      - repo
      - code
      - network
    runs-on: ubuntu-latest
    env:
      TF_VAR_lambda_zip: ${{ needs.code.outputs.lambda_zip }}
      TF_VAR_lambda_bucket: ${{ needs.repo.outputs.lambda_code_bucket }}
      TF_VAR_lb_security_group_id: ${{ needs.network.outputs.lb_security_group_id }}
      TF_VAR_lb_target_group_arn: ${{ needs.network.outputs.lb_lambda_target_group_arn}}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.aws_region }}
          role-to-assume: arn:aws:iam::${{ vars.aws_account_id }}:role/${{ vars.aws_role }}
          role-session-name: GitHubActions

      - name: Init
        shell: bash
        run: |
          cd tf/lambda
          terraform init
        
      - name: Deploy
        shell: bash
        id: deploy
        run: |
          cd tf/lambda
          terraform apply -auto-approve -var-file=${{ github.workspace }}/variables.tfvars

  test:
    runs-on: ubuntu-latest
    needs:
      - network
      - ecs
      - lambda
    steps:
      - name: url
        run: echo ${{ needs.network.outputs.api_invoke_url}}/host
      - name: sleep
        run: sleep 60
      - name: Hit the /host endpoint 10 times and assert backend distribution
        run: |
          LAMBDA_COUNT=0
          ECS_COUNT=0
          TOTAL_REQUESTS=10

          EXPECTED_LAMBDA_HITS=$(( (TOTAL_REQUESTS * ${{ github.env.lambda_traffic_percentage }}) / 100 ))
          EXPECTED_ECS_HITS=$(( (TOTAL_REQUESTS * ${{ github.env.ecs_traffic_percentage }}) / 100 ))
  
          # Define a small range for tolerance, e.g., Â±1
          RANGE_TOLERANCE=1
          MIN_LAMBDA_HITS=$(( EXPECTED_LAMBDA_HITS - RANGE_TOLERANCE ))
          MAX_LAMBDA_HITS=$(( EXPECTED_LAMBDA_HITS + RANGE_TOLERANCE ))
          MIN_ECS_HITS=$(( EXPECTED_ECS_HITS - RANGE_TOLERANCE ))
          MAX_ECS_HITS=$(( EXPECTED_ECS_HITS + RANGE_TOLERANCE ))

          # Loop to hit the endpoint 10 times
          for i in {1..$TOTAL_REQUESTS}; do
            RESPONSE=$(curl -s ${{ needs.network.outputs.api_invoke_url}}/host)
            echo "$RESPONSE" | jq
            BACKEND=$(echo "$RESPONSE" | jq -r '.backend')

            # Check if the backend field exists
            if [[ "$BACKEND" == "null" ]]; then
              echo "Error: Response does not contain backend field."
              exit 1
            fi

            # Increment counters based on backend value
            if [[ "$BACKEND" == "lambda" ]]; then
              LAMBDA_COUNT=$((LAMBDA_COUNT + 1))
            elif [[ "$BACKEND" == "ecs" ]]; then
              ECS_COUNT=$((ECS_COUNT + 1))
            else
              echo "Error: Unknown backend '$BACKEND'."
              exit 1
            fi
          done

          echo "lambda was backend $LAMBDA_COUNT times and ecs was backend $ECS_COUNT times."

          # Assert that lambda was hit 9 times and ecs was hit 1 time
          if [[ "$LAMBDA_COUNT" -ge "$MIN_LAMBDA_HITS" && "$LAMBDA_COUNT" -le "$MAX_LAMBDA_HITS" && "$ECS_COUNT" -ge "$MIN_ECS_HITS" && "$ECS_COUNT" -le "$MAX_ECS_HITS" ]]; then
            echo "Test passed: Lambda was backend between $MIN_LAMBDA_HITS and $MAX_LAMBDA_HITS times, and ECS was backend between $MIN_ECS_HITS and $MAX_ECS_HITS times."
          else
            echo "Test failed: Lambda was backend $LAMBDA_COUNT times and ECS was backend $ECS_COUNT times."
            exit 1
          fi

  negative_test:
    runs-on: ubuntu-latest
    needs:
      - network
      - ecs
      - lambda
    steps:
      - name: sleep
        run: sleep 45
      - name: Negative test for 404 response
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${{ needs.network.outputs.api_invoke_url}}/no/exists/)
          
          # Check if the response status code is 404
          if [[ "$RESPONSE" -ne 404 ]]; then
            echo "Error: Expected 404 response, but got $RESPONSE."
            exit 1
          else
            echo "Negative test passed: Received expected 404 response."
          fi
